# テスト実施のための技術要素ガイド

## 1. テストフレームワーク・ツール セットアップ

### 1.1 必要なパッケージ

**requirements-dev.txt**:
```
# ベース
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
pytest-mock==3.12.0
pytest-flask==1.3.0

# モック・スタブ
unittest-mock==1.5.0

# ツール
coverage==7.3.2
```

**インストール**:
```bash
pip install -r requirements-dev.txt
```

---

## 2. pytest の基本

### 2.1 テストファイル命名規則

```
tests/
├── unit/
│   ├── test_midi_generation.py
│   ├── test_mp3_conversion.py
│   └── ...
├── integration/
│   ├── test_endpoints.py
│   └── ...
└── conftest.py
```

**命名ルール**:
- ファイル: `test_*.py` または `*_test.py`
- 関数: `test_*`
- クラス: `Test*`

### 2.2 基本的なテスト構造

```python
import pytest
from app import generate_random_midi

def test_generate_random_midi_basic():
    """メジャースケール生成テスト"""
    # Arrange（準備）
    scale = "major"
    base_note = "C"
    
    # Act（実行）
    result = generate_random_midi(scale, base_note, "test")
    
    # Assert（検証）
    assert result is not None
    assert result.endswith('.mid')
```

### 2.3 テスト実行コマンド

```bash
# 全テスト実行
pytest

# 特定ファイルのみ
pytest tests/unit/test_midi_generation.py

# 特定テスト関数のみ
pytest tests/unit/test_midi_generation.py::test_generate_random_midi_basic

# 詳細表示
pytest -v

# 失敗時に標準出力表示
pytest -s

# 最初の失敗で停止
pytest -x

# 最後の3つのテスト結果から開始（失敗時の再実行）
pytest --lf

# マーク付きテストのみ
pytest -m "unit"

# キーワードで絞り込み
pytest -k "midi"
```

---

## 3. フィクスチャ（Fixture）

### 3.1 基本的なフィクスチャ

**conftest.py**:
```python
import pytest
import os
import tempfile
from flask import Flask
from app import app

@pytest.fixture
def test_app():
    """Flask アプリケーション"""
    app.config['TESTING'] = True
    yield app

@pytest.fixture
def client(test_app):
    """テストクライアント"""
    return test_app.test_client()

@pytest.fixture
def temp_dir():
    """一時ディレクトリ"""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir

@pytest.fixture
def temp_midi_file(temp_dir):
    """一時MIDIファイル"""
    from app import generate_random_midi
    midi_file = generate_random_midi("major", "C", "test")
    yield midi_file
    # クリーンアップ
    if os.path.exists(midi_file):
        os.remove(midi_file)

@pytest.fixture
def session_with_files(client):
    """ファイル付きセッション"""
    response = client.post('/generate_music', data={
        'scale': 'major',
        'base_note': 'C'
    })
    yield client
    # クリーンアップ
    client.post('/clear_session')
```

### 3.2 フィクスチャのスコープ

```python
@pytest.fixture(scope="function")  # デフォルト（各テスト実行時）
def fixture_function():
    pass

@pytest.fixture(scope="class")     # クラス単位
def fixture_class():
    pass

@pytest.fixture(scope="module")    # モジュール単位
def fixture_module():
    pass

@pytest.fixture(scope="session")   # セッション単位（全テスト共通）
def fixture_session():
    pass
```

---

## 4. モック・スタブ・スパイ

### 4.1 unittest.mock の使い方

```python
from unittest.mock import Mock, patch, MagicMock, call

# Mock オブジェクト作成
mock_obj = Mock()
mock_obj.method.return_value = "mocked result"

# 呼び出し検証
assert mock_obj.method.called
assert mock_obj.method.call_count == 1
assert mock_obj.method.call_args == call("arg1", "arg2")

# Stub：戻り値設定
mock_obj.another_method.return_value = 42

# Spy：実際のオブジェクトをスパイ（呼び出し追跡）
from app import notetoname
with patch('app.notetoname', wraps=notetoname) as spy:
    result = spy(0)
    assert spy.called
    assert result == "C"
```

### 4.2 関数のモック化

**パターン1：関数全体をモック**
```python
from unittest.mock import patch
from app import generate_mp3

@patch('app.generate_mp3')
def test_with_mocked_function(mock_generate_mp3):
    """MP3生成をモック化"""
    mock_generate_mp3.return_value = "/path/to/test.mp3"
    
    # テストコード
    result = mock_generate_mp3("test.mid", "test")
    assert result == "/path/to/test.mp3"
```

**パターン2：モジュール内の関数をモック**
```python
@patch('app.subprocess.run')
def test_timidity_call(mock_subprocess):
    """Timidity の呼び出しをモック"""
    mock_subprocess.return_value = Mock(returncode=0)
    
    # テストコード
    # generate_mp3 内で subprocess.run が呼ばれる
```

**パターン3：コンテキストマネージャでモック**
```python
def test_with_context_manager():
    """コンテキストマネージャ形式"""
    with patch('app.generate_mp3') as mock_mp3:
        mock_mp3.return_value = "/path/to/test.mp3"
        
        # テストコード
        pass
```

### 4.3 非同期関数のモック

```python
from unittest.mock import AsyncMock

@patch('app.generate_mp3', new_callable=AsyncMock)
async def test_async_function(mock_generate_mp3):
    """非同期関数のモック"""
    mock_generate_mp3.return_value = "/path/to/test.mp3"
    
    result = await mock_generate_mp3("test.mid", "test")
    assert result == "/path/to/test.mp3"
```

### 4.4 副作用（Side Effects）

```python
from unittest.mock import Mock

# 複数回の呼び出しで異なる値を返す
mock_obj = Mock(side_effect=[1, 2, 3])
print(mock_obj())  # 1
print(mock_obj())  # 2
print(mock_obj())  # 3

# 例外を発生させる
mock_error = Mock(side_effect=FileNotFoundError("File not found"))
with pytest.raises(FileNotFoundError):
    mock_error()

# 関数を実行
def custom_side_effect(arg):
    return arg * 2

mock_func = Mock(side_effect=custom_side_effect)
assert mock_func(5) == 10
```

---

## 5. Flask テスト（APIテスト）

### 5.1 テストクライアントの基本

```python
def test_get_endpoint(client):
    """GETエンドポイントテスト"""
    response = client.get('/')
    assert response.status_code == 200

def test_post_endpoint(client):
    """POSTエンドポイントテスト"""
    response = client.post('/generate_music', data={
        'scale': 'major',
        'base_note': 'C'
    })
    assert response.status_code == 200

def test_json_request(client):
    """JSON リクエストテスト"""
    response = client.post('/api/endpoint',
        json={'key': 'value'},
        headers={'Content-Type': 'application/json'}
    )
    assert response.status_code == 200
```

### 5.2 レスポンス検証

```python
def test_response_validation(client):
    """レスポンス検証"""
    response = client.post('/generate_music', data={
        'scale': 'major',
        'base_note': 'C'
    })
    
    # ステータスコード
    assert response.status_code == 200
    
    # Content-Type
    assert response.content_type == 'application/json'
    
    # JSONデータ
    data = response.get_json()
    assert 'notes' in data
    assert 'wav_file' in data
    assert isinstance(data['notes'], list)
    
    # HTMLレスポンス
    html = response.get_data(as_text=True)
    assert '<html>' in html
    
    # バイナリデータ
    binary_data = response.get_data()
    assert len(binary_data) > 0
```

### 5.3 セッション テスト

```python
def test_session_management(client):
    """セッション管理テスト"""
    # 1回目のリクエスト
    response1 = client.post('/generate_music', data={
        'scale': 'major',
        'base_note': 'C'
    })
    assert response1.status_code == 200
    
    # セッションデータ確認
    with client.session_transaction() as session:
        assert 'midi_file' in session
        midi_file = session['midi_file']
    
    # 2回目のリクエスト
    response2 = client.post('/generate_music', data={
        'scale': 'minor',
        'base_note': 'G'
    })
    
    # セッションが更新されていることを確認
    with client.session_transaction() as session:
        assert session['midi_file'] != midi_file
```

---

## 6. 非同期テスト（pytest-asyncio）

### 6.1 非同期テスト関数

```python
import pytest

@pytest.mark.asyncio
async def test_async_function():
    """非同期関数のテスト"""
    from app import generate_mp3
    
    # 非同期関数を実行
    result = await generate_mp3("test.mid", "test")
    assert result is not None
```

### 6.2 非同期フィクスチャ

```python
@pytest.fixture
async def async_fixture():
    """非同期フィクスチャ"""
    # セットアップ
    await setup_async_resource()
    
    yield "resource"
    
    # ティアダウン
    await cleanup_async_resource()

@pytest.mark.asyncio
async def test_with_async_fixture(async_fixture):
    """非同期フィクスチャを使用"""
    assert async_fixture == "resource"
```

### 6.3 asyncio.run と await

```python
import asyncio

# 方法1：@pytest.mark.asyncio（推奨）
@pytest.mark.asyncio
async def test_method_1():
    result = await some_async_function()

# 方法2：asyncio.run を使用
def test_method_2():
    result = asyncio.run(some_async_function())

# 方法3：イベントループを手動管理
def test_method_3():
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(some_async_function())
```

---

## 7. カバレッジ測定

### 7.1 カバレッジコマンド

```bash
# カバレッジ測定
pytest --cov=app --cov-report=html --cov-report=term-missing

# 特定ディレクトリのみ
pytest --cov=app/handlers --cov-report=html

# カバレッジ最小値チェック
pytest --cov=app --cov-fail-under=80
```

### 7.2 カバレッジレポート解釈

```
Name                      Stmts   Miss  Cover   Missing
─────────────────────────────────────────────────────
app.py                      200     20    90%    45-50, 120-125
utils.py                     50      5    90%    30-35
─────────────────────────────────────────────────────
TOTAL                       250     25    90%
```

**見方**:
- **Stmts**: ステートメント総数
- **Miss**: カバーされていないステートメント数
- **Cover**: カバレッジ率（%）
- **Missing**: カバーされていない行番号

### 7.3 .coveragerc 設定

```ini
[run]
source = app
branch = True
omit =
    */tests/*
    */site-packages/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:

[html]
directory = htmlcov
```

---

## 8. テストダブル パターン

### 8.1 Mock（モック）

**用途**: 動作検証、呼び出し確認
```python
from unittest.mock import Mock

mock_file = Mock()
mock_file.read.return_value = b"file content"

# テストコード
result = mock_file.read()

# 検証
mock_file.read.assert_called_once()
```

### 8.2 Stub（スタブ）

**用途**: 戻り値設定、簡易実装
```python
class StubMidiFile:
    """MIDI ファイルのスタブ"""
    def __init__(self):
        self.tracks = [MockTrack()]
    
    def save(self, path):
        return True

class MockTrack:
    def __init__(self):
        self.messages = []
```

### 8.3 Spy（スパイ）

**用途**: 実装を保持しながら呼び出し追跡
```python
from unittest.mock import patch

with patch('app.generate_random_midi', wraps=generate_random_midi) as spy:
    result = spy("major", "C", "test")
    
    # 実装は実行されつつ、呼び出し情報を記録
    assert spy.called
    assert result is not None
```

### 8.4 Fake（フェイク）

**用途**: 実際の実装の簡易版
```python
class FakeMidiFile:
    """テスト用の簡易MIDI実装"""
    def __init__(self):
        self.tracks = []
    
    def add_track(self, name=""):
        track = FakeTrack()
        self.tracks.append(track)
        return track
    
    def save(self, path):
        # ダミー実装
        with open(path, 'w') as f:
            f.write("FAKE MIDI")

class FakeTrack:
    def __init__(self):
        self.messages = []
```

---

## 9. テスト データ

### 9.1 テストデータ クラス

```python
from dataclasses import dataclass

@dataclass
class TestMidiData:
    """テスト用MIDIデータ"""
    scale: str
    base_note: str
    expected_note_count: int
    expected_status_code: int

# テストパラメータ化で使用
TEST_CASES = [
    TestMidiData("major", "C", 15, 200),
    TestMidiData("minor", "G", 20, 200),
    TestMidiData("invalid", "H", 0, 400),
]
```

### 9.2 パラメータ化テスト

```python
import pytest

@pytest.mark.parametrize("scale,base_note,expected", [
    ("major", "C", 200),
    ("minor", "G", 200),
    ("invalid", "H", 400),
])
def test_generate_music_parametrized(client, scale, base_note, expected):
    """パラメータ化テスト"""
    response = client.post('/generate_music', data={
        'scale': scale,
        'base_note': base_note
    })
    assert response.status_code == expected
```

### 9.3 テストデータファイル

```python
import json

def load_test_data(filename):
    """テストデータファイル読み込み"""
    with open(f'tests/data/{filename}') as f:
        return json.load(f)

# tests/data/test_cases.json
{
    "valid_cases": [
        {"scale": "major", "base_note": "C", "expected": 200}
    ],
    "invalid_cases": [
        {"scale": "invalid", "base_note": "H", "expected": 400}
    ]
}
```

---

## 10. エラー・例外テスト

### 10.1 例外テスト

```python
import pytest

def test_exception_raised():
    """例外が発生することを確認"""
    with pytest.raises(ValueError):
        some_function("invalid_input")

def test_exception_message():
    """例外メッセージを確認"""
    with pytest.raises(ValueError, match="Expected error message"):
        some_function("invalid_input")

def test_exception_type_and_value():
    """例外の型と値を確認"""
    with pytest.raises(FileNotFoundError) as exc_info:
        open("nonexistent_file.txt")
    
    assert "nonexistent_file.txt" in str(exc_info.value)
```

### 10.2 HTTP エラーレスポンステスト

```python
def test_invalid_parameter_error(client):
    """無効なパラメータエラーテスト"""
    response = client.post('/generate_music', data={
        'scale': 'invalid_scale'
    })
    
    assert response.status_code == 400
    data = response.get_json()
    assert 'error' in data
    assert 'invalid_scale' in data['error'].lower() or 'scale' in data['error'].lower()
```

---

## 11. マーク（Mark）

### 11.1 テストマーク

```python
import pytest

@pytest.mark.unit
def test_unit_test():
    """ユニットテスト"""
    pass

@pytest.mark.integration
def test_integration_test():
    """統合テスト"""
    pass

@pytest.mark.slow
def test_slow_test():
    """時間がかかるテスト"""
    pass

@pytest.mark.skip(reason="未実装")
def test_not_implemented():
    """スキップするテスト"""
    pass

@pytest.mark.xfail(reason="既知の問題")
def test_expected_failure():
    """失敗が予期されるテスト"""
    pass

@pytest.mark.skipif(sys.version_info < (3, 10), reason="Python 3.10+ 必須")
def test_python_version_requirement():
    """バージョン条件付きスキップ"""
    pass
```

### 11.2 マーク実行

```bash
# 特定マークのテストのみ実行
pytest -m "unit"
pytest -m "integration"
pytest -m "not slow"

# 複数マーク
pytest -m "unit or integration"
```

### 11.3 pytest.ini マーク定義

```ini
[pytest]
markers =
    unit: ユニットテスト
    integration: 統合テスト
    e2e: E2Eテスト
    security: セキュリティテスト
    slow: 時間がかかるテスト
```

---

## 12. テストスタイル・ベストプラクティス

### 12.1 AAA パターン（Arrange-Act-Assert）

```python
def test_aaa_pattern():
    """AAA パターンテスト"""
    # Arrange（準備）
    input_data = {"scale": "major", "base_note": "C"}
    expected_count = 15
    
    # Act（実行）
    result = generate_random_midi(**input_data, filename_prefix="test")
    midi = MidiFile(result)
    note_count = count_notes(midi)
    
    # Assert（検証）
    assert note_count > 0
    
    # Cleanup
    os.remove(result)
```

### 12.2 テスト関数の命名

```python
# 悪い例
def test_func():
    pass

# 良い例
def test_generate_random_midi_returns_valid_midi_file():
    """関数名で何をテストしているか明確"""
    pass

def test_generate_random_midi_with_major_scale():
    """パラメータを含める"""
    pass

def test_generate_random_midi_raises_value_error_for_invalid_scale():
    """エラーテストも明確"""
    pass
```

### 12.3 テスト間の依存性を避ける

```python
# 悪い例：テスト間の依存性
def test_first(client):
    client.post('/generate_music', data={'scale': 'major'})

def test_second(client):
    # test_first が実行されたことに依存
    response = client.get('/random.mp3')
    assert response.status_code == 200

# 良い例：独立したテスト
def test_first(client):
    response = client.post('/generate_music', data={'scale': 'major'})
    assert response.status_code == 200

def test_second(client):
    # セットアップを含める
    client.post('/generate_music', data={'scale': 'major'})
    response = client.get('/random.mp3')
    assert response.status_code == 200
```

### 12.4 明確なアサーション

```python
# 悪い例
assert result

# 良い例
assert result is not None
assert isinstance(result, str)
assert result.endswith('.mid')
assert len(result) > 0

# メッセージ付き
assert result.endswith('.mid'), f"Expected .mid extension, got {result}"
```

---

## 13. pytest.ini 設定

```ini
[pytest]
# テスト発見パターン
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*

# マーク定義
markers =
    unit: ユニットテスト
    integration: 統合テスト
    slow: 時間がかかるテスト

# 出力設定
addopts = 
    -v
    --tb=short
    --strict-markers
    -ra

# テストパス
testpaths = tests

# カバレッジ設定
[coverage:run]
source = app
branch = True
```

---

## 14. 実装例：完全なテストモジュール

**tests/unit/test_midi_generation.py**:
```python
import pytest
import os
from mido import MidiFile
from app import generate_random_midi

class TestGenerateRandomMidi:
    """MIDI生成関数テストクラス"""
    
    @pytest.fixture
    def midi_file(self):
        """MIDI ファイルフィクスチャ"""
        file_path = generate_random_midi("major", "C", "test")
        yield file_path
        if os.path.exists(file_path):
            os.remove(file_path)
    
    def test_returns_valid_path(self, midi_file):
        """有効なパスを返すテスト"""
        assert midi_file is not None
        assert midi_file.endswith('.mid')
    
    def test_file_exists(self, midi_file):
        """ファイルが存在するテスト"""
        assert os.path.exists(midi_file)
        assert os.path.isfile(midi_file)
    
    def test_can_be_parsed_by_mido(self, midi_file):
        """mido で読込可能なテスト"""
        midi = MidiFile(midi_file)
        assert len(midi.tracks) > 0
    
    @pytest.mark.parametrize("scale,base_note", [
        ("major", "C"), ("minor", "G"), ("major", "A#")
    ])
    def test_all_scales_and_notes(self, scale, base_note):
        """全スケール・基準音のテスト"""
        midi_file = generate_random_midi(scale, base_note, "test")
        assert os.path.exists(midi_file)
        os.remove(midi_file)
```

---

## 15. トラブルシューティング

### 15.1 よくある問題

| 問題 | 原因 | 解決策 |
|------|------|--------|
| **ImportError: No module named pytest** | pytest がインストールされていない | `pip install pytest` |
| **asyncio.run_until_complete() が実行されない** | マークがない | `@pytest.mark.asyncio` を追加 |
| **モックが機能しない** | パッチパスが間違っている | `patch('app.function')` 形式を確認 |
| **セッションが見つからない** | `session_transaction()` を使用していない | `with client.session_transaction()` を使用 |
| **ファイルが削除されない** | クリーンアップがない | フィクスチャで `yield` 後に削除処理 |

---

**作成日**: 2026年1月11日
**対象**: ランダムMIDI音楽生成アプリケーション テスト実装
